* 计算机网络
** TCP/IP 协议族

*** 互联网地址 
    - A 类地址范围：0.0.0.0~127.255.255.255，
    - B 类地址范围：128.0.0.0~191.255.255.255，
    - C 类地址范围：192.0.0.0~223.255.255.255，
    - D 类地址范围：224.0.0.0~239.255.255.255，
    - E 类地址范围：240.0.0.0~247.255.255.255.
      
   私有地址 
   10.0.0.0 ~ 10.255.255.255 (10/8) A 类
   172.16.0.0 ~ 172.31.255.255( 172.16/12) B 类
   192.168.0.0 ~ 192.168.255.255 (192.168/16) C 类

   FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF

*** 端口号 
    TCP 和 UDP 使用 16 位端口号来识别应用程序
    
** HTTP
   Hyper Text Transfer Protocol 是用于从万维网服务器传输超文本到本地浏览器的传送
   协议，适用于分布式超媒体信息系统

   HTTP 协议工作于客户端-服务端架构之上。浏览器作为 HTTP 客户端通过 URL 向 HTTP
   服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响
   应信息。

*** HTTP 之请求消息 Request
    
    #+begin_example
    GET /562f25980001b1b106000338.jpg HTTP/1.1
    Host    img.mukewang.com
    User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
    Accept    image/webp,image/*,*/*;q=0.8
    Referer    http://www.imooc.com/
    Accept-Encoding    gzip, deflate, sdch
    Accept-Language    zh-CN,zh;q=0.8

    name=Professional%20Ajax&publisher=Wiley  [主体]
    #+end_example

*** HTTP 之响应消息 Response

    #+begin_example
    HTTP/1.1 200 OK
    Date: Fri, 22 May 2009 06:07:21 GMT
    Content-Type: text/html; charset=UTF-8

    <html>
    <head></head>
      <body>
            <!--body goes here-->
      </body>
      </html>
    #+end_example

*** HTTP 之状态码

    #+begin_example
    200 OK                        //客户端请求成功
    400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
    401 Unauthorized              //请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 
    403 Forbidden                 //服务器收到请求，但是拒绝提供服务
    404 Not Found                 //请求资源不存在，eg：输入了错误的 URL
    500 Internal Server Error     //服务器发生不可预期的错误
    503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
    #+end_example

*** 流程

    1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
    2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;
    3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
    4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
    5、释放 TCP 连接;
    6、浏览器将该 html 文本并显示内容; 


### HTTP
#### POST 
##### application/x-www-form-urlencoded  (原生协议)
```
POST http://www.example.com HTTP/1.1
Content-Type: application/x-www-form-urlencoded;charset=utf-8

title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3
```
数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。例如 PHP 中，_POST['sub'] 可以得到 sub 数组

##### multipart/form-data (原生)
> 表单上传文件时，必须让 form 的 enctyped 等于这个值

``` 
POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA

------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name="text"

------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name="file"; filename="chrome.png"
Content-Type: image/png

PNG ... content of chrome.png ...
------WebKitFormBoundaryrGKCBY7qhFd3TrwA--
```

##### application/json
> 使用 JSON.stringify 系列化后的 json 字符串

```
POST http://www.example.com HTTP/1.1
Content-Type: application/json;charset=utf-8

{"title":"test","sub":[1,2,3]}
```

##### text/xml (使用较少)

``` 
POST http://www.example.com HTTP/1.1
Content-Type: text/xml

<!--?xml version="1.0"?-->
<methodcall>
    <methodname>examples.getStateName</methodname>
    <params>
        <param>
            <value><i4>41</i4></value>

    </params>
</methodcall>
```
